# AMCG-Pybaselines ASPLS 알고리즘 최적화 계획

## 현재 구현 분석

ASPLS (Adaptive Smoothness Penalized Least Squares) 알고리즘은 다음 위치에 구현되어 있습니다:
- `/amcg_pybaselines/whittaker.py` - 라인 505-609

### 주요 병목 지점 식별

1. **반복적인 행렬 연산**
   - 매 반복마다 선형 시스템을 풀어야 함 (라인 591-594)
   - 대역 행렬 곱셈과 역행렬 계산이 주요 연산 부담

2. **가중치 계산**
   - `_weighting._aspls()` 함수에서 sigmoid 함수 계산 (라인 595)
   - 잔차 계산과 표준편차 계산이 반복됨

3. **메모리 할당**
   - 매 반복마다 새로운 배열 생성
   - 특히 `lhs` 행렬이 매번 재생성됨 (라인 587-590)

## 최적화 전략

### 1. 계산 최적화

#### 1.1 조기 종료 조건 개선
- 현재: 가중치 변화량만 확인
- 개선: 연속된 반복에서 baseline 변화가 작을 때도 종료
- 예상 효과: 불필요한 반복 20-30% 감소

#### 1.2 적응적 람다 업데이트
- 초기 반복에서는 큰 람다 값으로 빠른 수렴
- 후반부에서 정밀한 조정
- 예상 효과: 전체 반복 횟수 감소

### 2. 메모리 최적화

#### 2.1 사전 할당 및 재사용
- `lhs` 행렬을 미리 할당하고 재사용
- 임시 배열들을 클래스 속성으로 관리
- 예상 효과: 메모리 할당 오버헤드 50% 감소

#### 2.2 인플레이스 연산
- numpy 연산에서 `out` 파라미터 활용
- 복사 대신 직접 수정
- 예상 효과: 메모리 사용량 30% 감소

### 3. 알고리즘 개선

#### 3.1 웜 스타트 (Warm Start)
- 이전 실행 결과를 다음 실행의 초기값으로 사용
- 비슷한 데이터에 대해 빠른 수렴
- 예상 효과: 반복 횟수 40-50% 감소

#### 3.2 적응적 반복 횟수
- 데이터 특성에 따라 max_iter 자동 조정
- 노이즈 레벨 추정하여 적절한 반복 횟수 결정

### 4. 병렬화 고려사항

#### 4.1 벡터화 개선
- 가중치 계산 부분 최적화
- numpy의 벡터화 연산 최대한 활용

#### 4.2 Numba JIT 컴파일
- 핵심 루프에 @njit 데코레이터 적용 고려
- 특히 가중치 계산 함수

## 구현 우선순위

1. **높음**: 메모리 재사용 및 인플레이스 연산
2. **높음**: 조기 종료 조건 개선
3. **중간**: 웜 스타트 기능
4. **낮음**: Numba 최적화 (의존성 추가 필요)

## 예상 성능 향상

- 전체 실행 시간: 40-60% 단축
- 메모리 사용량: 30-40% 감소
- 대용량 데이터(>100k 포인트)에서 특히 효과적

## 테스트 계획

1. 기존 테스트 케이스 통과 확인
2. 성능 벤치마크 작성
3. 다양한 데이터 크기에서 속도 비교
4. 결과 정확도 검증